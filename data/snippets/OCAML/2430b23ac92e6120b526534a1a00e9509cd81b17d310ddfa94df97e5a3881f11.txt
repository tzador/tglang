let rec mergeSort list =                        (* Define a function called mergeSort that takes in a list parameter *)
  if List.length list <= 1 then list            (* Check if the length of the list is less than or equal to 1, if true, return the list *)
  else                                           (* If not, continue with the sorting process *)
    let leftList = ref []                       (* Create a reference variable called leftList, initialize it as an empty list *)
    let rightList = ref []                      (* Create a reference variable called rightList, initialize it as an empty list *)
    let midpoint = List.length list / 2 in      (* Find the midpoint index of the list, using integer division *)
    for i = 0 to midpoint - 1 do                   (* Loop through the first half of the list *)
      leftList := List.nth list i :: !leftList     (* Add the elements of the first half to the leftList reference variable *)
    done                                           (* End of for loop *)
    for i = midpoint to List.length list - 1 do    (* Loop through the second half of the list *)
      rightList := List.nth list i :: !rightList   (* Add the elements of the second half to the rightList reference variable *)
    done                                           (* End of for loop *)
    let sortedLeftList = mergeSort !leftList      (* Call the mergeSort function recursively on the leftList and save the sorted list in a new variable *)
    let sortedRightList = mergeSort !rightList    (* Call the mergeSort function recursively on the rightList and save the sorted list in a new variable *)
    let rec merge l1 l2 =                          (* Define a helper function called merge that takes in two lists as parameters *)
      match l1, l2 with                              (* Match the two lists *)
      | [], [] -> []                                 (* If both lists are empty, return an empty list *)
      | [], l2 -> l2                                 (* If the first list is empty, return the second list *)
      | l1, [] -> l1                                 (* If the second list is empty, return the first list *)
      | h1 :: t1, h2 :: t2 ->                         (* If both lists have elements, compare the first elements *)
        if h1 <= h2 then                              (* If the first element in the first list is smaller or equal to the first element in the second list *)
          h1 :: (merge t1 l2)                         (* Add the first element to the merged list and recursively call merge with the rest of the first list and the second list *)
        else                                          (* If the first element in the second list is smaller *)
          h2 :: (merge l1 t2)                         (* Add the second element to the merged list and recursively call merge with the first list and the rest of the second list *)
    let mergedList = merge sortedLeftList sortedRightList    (* Call the merge function with the sorted left and right lists and save the merged list in a new variable *)
    mergedList                                     (* Return the merged and sorted list *)