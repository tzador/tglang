(* Define a recursive function to calculate the factorial of a number *)
let rec factorial n =
  if n = 0 then 1 (* Base case, factorial of 0 is 1 *)
  else n * factorial (n - 1) (* Recursive case, multiple n with factorial of n-1 *)

(* Define a function to print the first n terms of the Fibonacci sequence *)
let rec fibonacci n =
  match n with (* Use pattern matching to handle different n values *)
  | 0 -> [] (* Base case, for 0 terms, return empty list *)
  | 1 -> [0] (* Return list with first term as 0 for n = 1 *)
  | n -> (* Recursive case, use tail recursion to build list of Fibonacci sequence *)
    let rec helper a b count = (* Define a helper function with accumulator variables *)
      if count = 0 then [] (* Base case, return empty list when count reaches 0 *)
      else (* Recursive case, add next term to list and update accumulator variables *)
        let new_term = a + b in
        new_term :: helper b new_term (count - 1)
    in
    helper 0 1 (n - 1) (* Call helper function with initial values and n-1 as count *)

(* Define a higher order function to check if a number is prime *)
let is_prime n =
  (* Use Sieve of Eratosthenes algorithm to generate list of primes up to n *)
  let rec sieve is_prime_list n =
    match is_prime_list with
    | [] -> if n = 2 then true else false (* If list is empty and n is 2, return true, otherwise false *)
    | hd :: tl -> (* Recursive case, check if n is divisible by current prime number *)
      if n mod hd = 0 then false else sieve tl n
  in
  sieve (fibonacci n) n (* Call sieve function with list of primes generated by fibonacci function and n *)

(* Define a function to print all prime numbers in a range *)
let print_prime_range start stop =
  let rec prime_range_helper current =
    if current > stop then () (* If current value exceeds stop, return empty tuple *)
    else (* Recursive case, check if current value is prime and print if true *)
      if is_prime current then print_int current;
      print_string " ";
      prime_range_helper (current + 1)
  in
  prime_range_helper start (* Call helper function with start as initial value *)