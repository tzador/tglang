let list1 = [1; 2; 3; 4; 5] (*creating a list with integers from 1 to 5*)
let rec factorial x = (*defining a recursive function called 'factorial' that takes in one argument*)
  if x = 0 then 1 (*factorial of 0 is 1*)
  else x * factorial (x-1) (*recursive call to 'factorial' function to find factorial of x-1 *)
in (*terminates the 'rec' keyword*)
let rec fib n = (*defining a recursive function called 'fib' that takes in one argument*)
  if n = 0 then 0(*fibonacci of 0 is 0*)
  else if n = 1 then 1(*fibonacci of 1 is 1*)
  else fib (n-1) + fib (n-2) (*recursive call to 'fib' function to find fibonacci of n-1 and n-2*)
in (*terminates the 'rec' keyword*)
let rec map func l = (*defining a recursive function called 'map' that takes in two arguments*)
  match l with (*pattern matching on the list*)
  | [] -> [] (*if list is empty, return an empty list*)
  | h::t -> func h :: map func t (*apply input function to head of list and recursively call 'map' function on the tail of list*)
in (*terminates the 'rec' keyword*)
let filtered_list = map factorial list1 (*applying 'map' function with 'factorial' function to 'list1'*)
let final_result = map fib filtered_list (*applying 'map' function with 'fib' function to 'filtered_list'*)
(*final_result is a list of integers representing the factorial of each fibonacci number in list1*)