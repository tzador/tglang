(* This is a list comprehension in OCAML *)
let rec combinations l1 l2 = (* Define recursive function with two list parameters *)
    match l1 with (* Start a pattern matching *)
    | [] -> [] (* If first list is empty, return empty list *)
    | h1::t1 -> (* Otherwise, split first list into head and tail *)
        match l2 with (* Start a second pattern matching *)
        | [] -> [] (* If second list is empty, return empty list *)
        | h2::t2 -> (* Otherwise, split second list into head and tail *)
            (h1,h2) :: combinations l1 t2 (* Return a tuple of the first element from both lists and recursively call function with first list and tail of second list *)
            @ combinations t1 l2 (* Concatenate with recursively calling function with tail of first list and second list *)
(* Example usage *)
let result = combinations [1; 2; 3] ["a"; "b"; "c"] (* Call function with two lists as parameters *)
(* Output: [(1,"a"); (1,"b"); (1,"c"); (2,"a"); (2,"b"); (2,"c"); (3,"a"); (3,"b"); (3,"c")] *)