let rec fib n =                             (* Function to calculate the nth Fibonacci number *)
  if (n < 2) then n                          (* Return n if n is less than 2 *)
  else fib (n-1) + fib (n-2)                 (* Calculate the sum of the previous two Fibonacci numbers *)

let rec power x n =                          (* Function to calculate the power of a number *)
  if (n = 0) then 1                          (* Return 1 if the power is 0 *)
  else if (n mod 2 = 0) then                 (* Calculate the power recursively if n is even *)
    let sqrt = power x (n/2) in              (* Calculate the square root of x to the power of half n *)
    sqrt * sqrt                              (* Return the square of the square root *)
  else                                       (* Calculate the power recursively if n is odd *)
    let sqrt = power x (n/2) in              (* Calculate the square root of x to the power of half n *)
    x * sqrt * sqrt                          (* Return x multiplied by the square of the square root *)

let rec merge_sort lst =                     (* Function to sort a list using Merge Sort *)
  let rec split lst =                        (* Function to split a list into two sub-lists *)
    let rec aux lst acc1 acc2 =              (* Helper function to split the list into two sub-lists *)
      match lst with
      | [] -> (acc1, acc2)                   (* Return the two sub-lists when the original list is empty *)
      | [x] -> (x :: acc1, acc2)             (* Add the remaining element to the first sub-list *)
      | x :: y :: rest -> aux rest (x :: acc1) (y :: acc2)   (* Add the first two elements to the sub-lists *)
    in                                         (* Call the helper function with an empty accumulator *)
    aux lst [] []                              (* Return the two sub-lists *)

  match lst with                            (* Match on the input list *)
  | [] -> []                                 (* Return an empty list if input is empty *)
  | [x] -> [x]                               (* Return the list if it contains only one element *)
  | lst -> let (first, second) = split lst in   (* Split the list into two sub-lists *)
           merge (merge_sort first) (merge_sort second) (* Sort and merge the two sub-lists *)

let rec merge lst1 lst2 =                    (* Function to merge two sorted lists into one *)
  match (lst1, lst2) with                    (* Match the two lists *)
  | ([], []) -> []                            (* Return an empty list when both lists are empty *)
  | ([], lst) -> lst                          (* Return the second list when the first list is empty *)
  | (lst, []) -> lst                          (* Return the first list when the second list is empty *)
  | (x :: rest1, y :: rest2) when (x < y) ->     (* Compare the first elements and add the smaller one to the result *)
      x :: merge rest1 lst2                     (* Recursively call the merge function with the remaining elements *)
  | (_, y :: _) -> y :: merge lst1 rest2      (* Add the second element to the result and recursively call the merge function with the remaining elements *)

let rec quick_sort lst =                     (* Function to sort a list using Quick Sort *)
  match lst with                             (* Match on the input list *)
  | [] -> []                                 (* Return an empty list if input is empty *)
  | [x] -> [x]                               (* Return the list if it contains only one element *)
  | pivot :: rest ->                         (* Pick a pivot element and split the list into two sub-lists *)
      let less, greater = List.partition (fun x -> x < pivot) rest in  (* Partition the list based on the pivot element *)
      quick_sort less                        (* Recursively sort the sub-list of elements smaller than the pivot *)
      @ [pivot]                              (* Add the pivot element to the result *)
      @ quick_sort greater                   (* Recursively sort the sub-list of elements greater than the pivot *)