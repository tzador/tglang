let rec merge_sort l = (* the function takes a list as input and returns a sorted list *)
  let rec merge_lst l1 l2 acc = (* helper function that merges two lists *)
    match (l1, l2) with
    | [], l -> List.rev_append acc l (* if list 1 is empty, append accumulator with the remaining elements of list 2 *)
    | l, [] -> List.rev_append acc l (* if list 2 is empty, append accumulator with the remaining elements of list 1 *)
    | (h1 :: t1 as l1), (h2 :: t2 as l2) -> (* if both lists have elements *)
      if h1 < h2 then (* if first element of list 1 is smaller than first element of list 2 *)
        merge_lst t1 l2 (h1 :: acc) (* append first element of list 1 to accumulator *)
      else (* if first element of list 2 is smaller than or equal to first element of list 1 *)
        merge_lst l1 t2 (h2 :: acc) (* append first element of list 2 to accumulator *)
  in
  match l with (* begin pattern matching on input list *)
  | [] -> [] (* if input list is empty, return empty list *)
  | [x] -> [x] (* if input list has only one element, return list as is *)
  | l -> (* if input list has more than one element, divide it into two sub-lists *)
    let mid = List.length l / 2 in (* calculate the middle index *)
    let l1, l2 = List.split_at mid l in (* split the list at the middle index *)
    let sorted_l1 = merge_sort l1 in (* recursively call merge_sort on first sub-list *)
    let sorted_l2 = merge_sort l2 in (* recursively call merge_sort on second sub-list *)
    merge_lst sorted_l1 sorted_l2 [] (* call helper function to merge the two sorted sub-lists and return the final sorted list *)