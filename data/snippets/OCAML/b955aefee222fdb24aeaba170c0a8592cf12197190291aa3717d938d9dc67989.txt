let rec map f l =  (* define a function called map that takes in a function f and a list l *)
  match l with  (* pattern match l *)
  | [] -> []  (* if l is an empty list, return an empty list *)
  | h::t -> f h :: map f t  (* if l is not empty, apply the function f to the head of l and recursively map f to the rest of l *)

let rec fold_left f a l =  (* define a function called fold_left that takes in a function f, an accumulator a, and a list l *)
  match l with  (* pattern match l *)
  | [] -> a  (* if l is an empty list, return the accumulator *)
  | h::t -> fold_left f (f a h) t  (* if l is not empty, apply the function f to the accumulator and the head of l, and recursively fold_left f to the rest of l *)

let rec filter p l =  (* define a function called filter that takes in a predicate p and a list l *)
  match l with  (* pattern match l *)
  | [] -> []  (* if l is an empty list, return an empty list *)
  | h::t -> if p h then h :: filter p t else filter p t  (* if l is not empty, check if the predicate p holds for the head of l, if it does, add it to the new list, if it doesn't, continue recursively filtering the rest of l *)

let rec take n l =  (* define a function called take that takes in an integer n and a list l *)
  match n, l with  (* pattern match n and l *)
  | n, _ when n <= 0 -> []  (* if n is less than or equal to 0, return an empty list *)
  | _, [] -> []  (* if l is an empty list, return an empty list *)
  | n, h::t -> h :: take (n-1) t  (* if both n and l are not empty, add the head of l to the new list and recursively take n-1 elements from the tail of l *)