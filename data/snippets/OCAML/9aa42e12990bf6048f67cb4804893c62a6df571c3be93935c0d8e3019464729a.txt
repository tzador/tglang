let rec fib n =               (* function declaration for fibonacci sequence with parameter n *)
  match n with                (* pattern matching for n *)
  | 0 -> 0                    (* if n is 0, return 0 *)
  | 1 -> 1                    (* if n is 1, return 1 *)
  | _ -> fib (n-1) + fib (n-2) (* for any other value of n, call fib recursively with n-1 and n-2 and add them together *)
  
let memo_fib =                   (* declaring a memoized version of the fib function *)
  let cache = ref [||] in        (* creating a reference to an empty array for caching values *)
  let rec memo n =               (* recursive function that takes in parameter n *)
    match !cache.(n) with        (* checking if value at index n in cache exists *)
    | v -> v                     (* if it does, return the cached value *)
    | exception _ ->             (* if it doesn't, catch exception and calculate the value *)
      let result = fib n in      (* calculate the value using regular fib function *)
      cache := Array.append !cache [|result|]; (* append the calculated value to the cache *)
      result                     (* return the calculated value *)
  in
  memo                            (* return the memoized function *)

let memo_fib_result = memo_fib 10 (* calling the memoized fib function with input 10 *) 
(* output: 55 *)                 (* returning the calculated result, which is the 10th value in the fibonacci sequence *)