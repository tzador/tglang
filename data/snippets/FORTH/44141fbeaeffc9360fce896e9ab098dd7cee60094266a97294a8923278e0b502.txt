: LENGTH-STRING ( str1 -- n )  ( calculates the length of a given string )
    0  ( initialize count variable )
    BEGIN  ( start loop )
        DUP C@ ( get the ASCII value of the current character )
        Z= IF ( check if it's the end of the string )
            DROP ( drop the current character )
            EXIT ( exit the loop )
        THEN
        1 ( add 1 to count )
        + ( increment count )
        1 ( move to next character )
        + ( increment current address )
    REPEAT  ( repeat until end of string is reached )
    DROP ( drop the current character )
; ( end of LENGTH-STRING definition )

.CR  ( output a carriage return )
.HEX  ( set output to hexadecimal )
: PRINT-STRING ( str -- )  ( prints out a given string )
    0 ( initialize index variable )
    BEGIN  ( start loop )
        DUP C@ ( get the ASCII value of the current character )
        Z= IF  ( check if it's the end of the string )
            EXIT  ( exit the loop )
        THEN
        DUP .  ( output current character onto stack )
        1 ( move to next character )
        + ( increment current address )
        1 ( add 1 to index )
        +  ( increment index )
    REPEAT  ( repeat until end of string is reached )
; ( end of PRINT-STRING definition )

: WORD-COUNT ( str -- n )  ( calculates the number of words in a given string )
    0  ( initialize count variable )
    BEGIN  ( start loop )
        DUP C@ ( get the ASCII value of the current character )
        Z= IF  ( check if it's the end of the string )
            EXIT  ( exit the loop )
        THEN
        DUP C@ BL !=  ( check if current character is not a space )
        IF
            1 ( add 1 to count )
            + ( increment count )
        THEN
        1 ( move to next character )
        + ( increment current address )
    REPEAT  ( repeat until end of string is reached )
    DROP ( drop the current character )
; ( end of WORD-COUNT definition )

: REPLACE ( str1 str2 str3 -- newStr )  ( replaces a given substring with another substring in a given string )
    BEGIN  ( start loop )
        DUP C@ SWAP C@  ( get the current character from str1 and str2 )
        Z= IF  ( check if str1 is an empty string )
            DROP ( drop the current character )
            DROP ( drop the end of str2 )
            ROT ( rotate and bring str3 to top of stack )
            SWAP ( swap str2 and newStr )
            EXIT  ( exit the loop )
        THEN
        OVER C@ SWAP C@ <>  ( check if current character in str1 is the same as first character in str2 )
        IF  ( if not equal, perform string concatenation )
            OVER ( copy current character from str1 )
            ROT ( rotate stack )
            TYPE ( concatenate current character to newStr )
        ELSE  ( if equal, drop the current character and continue with rest of str1 and str3 )
            DROP ( drop the current character )
            1 ( move to next character )
            + ( increment current address )
            ROT ( rotate stack )
        THEN
        1 ( move to next character in str1 )
        + ( increment current address )
    REPEAT  ( repeat until end of str1 or str2 is reached )
; ( end of REPLACE definition )

.("Hello, I am a FORTH code snippet!") ( prints out the message between the parentheses )
CR ( outputs a carriage return )
."The length of the message is: " ( prints out the message before the length )
 ."          (COUNT\_WORDS"  ( calls the replace function to replace spaces with underscores )
CR ( outputs a carriage return )
."The replaced message is: " ( prints out the message before the replacement )
."[](https://en.wikipedia.org/wiki/FORTH)" ( prints out the Wikipedia link without spaces )
CR ( outputs a carriage return )
."The number of words in the message is: " ( prints out the message before the word count )
> MARK ( defines a word MARK that marks the current position in memory )
"hello" MARK  ( marks the current position as the start of the string )
." " .(Hello) .(World!) ( prints out "Hello World!" )
." " MARK .(Goodbye) ( replaces "Hello" with "Goodbye" )
." " MARK .(Farewell) ( replaces "World!" with "Farewell" )
CR ( outputs a carriage return )
."The final message is: " ( prints out the message before the final replacement )
"hello" MARK ( marks the current position as the start of the string )
." " .(Goodbye) .(Farewell) ( prints out "Goodbye Farewell" )