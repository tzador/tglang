;;;; Simple implementation of a doubly-linked list data structure
;;;; Nodes contain an integer value and pointers to the next and previous nodes
;;;; Generated by Kelly Tayaco

(defclass node ()                                   ;;; Define a class 'node' for each node in the linked list
  ((value :accessor value                           ;;; Instance variable 'value' to hold the integer value of the node
          :initarg :value                            ;;; Use :initarg to initialize it when creating an instance
          :initform 0)                               ;;; Use :initform to set a default value of 0
   (next :accessor next                             ;;; Instance variable 'next' to hold a pointer to the next node
         :initarg :next                              ;;; Use :initarg to initialize it when creating an instance
         :initform nil)                              ;;; Use :initform to set a default value of nil
   (prev :accessor prev                             ;;; Instance variable 'prev' to hold a pointer to the previous node
         :initarg :prev                              ;;; Use :initarg to initialize it when creating an instance
         :initform nil)))                            ;;; Use :initform to set a default value of nil

(defclass linked-list ()                            ;;; Define a class 'linked-list' to hold the nodes
  ((head :accessor head                             ;;; Instance variable 'head' to hold a pointer to the first node
         :initform nil)                              ;;; Use :initform to set a default value of nil
   (tail :accessor tail                             ;;; Instance variable 'tail' to hold a pointer to the last node
         :initform nil)))                            ;;; Use :initform to set a default value of nil

(defmethod add-front (list node)                    ;;; Define a method 'add-front' to add a node to the front of the linked list
  (with-slots (head) list                            ;;; Use 'with-slots' to access the instance variables of the linked list
    (when (null head)                                ;;; If 'head' is nil, the linked list is empty
      (setf head node                                ;;; Set 'head' to the new node
            tail node))                              ;;; Set 'tail' to the new node
    (setf (next node) head)                          ;;; Set the new node's 'next' pointer to point to the previous head
    (setf (prev head) node)                          ;;; Set the previous head's 'prev' pointer to point to the new node
    (setf head node)))                               ;;; Set 'head' of the linked list to the new node

(defmethod add-back (list node)                     ;;; Define a method 'add-back' to add a node to the back of the linked list
  (with-slots (tail) list                            ;;; Use 'with-slots' to access the instance variables of the linked list
    (when (null tail)                                ;;; If 'tail' is nil, the linked list is empty
      (setf tail node                                ;;; Set 'tail' to the new node
            head node))                              ;;; Set 'head' to the new node
    (setf (prev node) tail)                          ;;; Set the new node's 'prev' pointer to point to the previous tail
    (setf (next tail) node)                          ;;; Set the previous tail's 'next' pointer to point to the new node
    (setf tail node)))                               ;;; Set 'tail' of the linked list to the new node

(defmethod remove-front (list)                      ;;; Define a method 'remove-front' to remove a node from the front of the linked list
  (with-slots (head) list                            ;;; Use 'with-slots' to access the instance variables of the linked list
    (when head                                       ;;; If 'head' is not nil, the linked list is not empty
      (let ((front head))                            ;;; Store the current head in 'front' variable
        (setf head (next head))                      ;;; Set 'head' to the next node
        (when head                                   ;;; If 'head' is not nil, the linked list still has nodes
          (setf (prev head) nil))                    ;;; Set the new head's 'prev' pointer to nil
        (when (eq front tail))                       ;;; If the node to remove is the last one in the list
          (setf tail nil))                           ;;; Set 'tail' to nil
        front))))                                     ;;; Return the removed node

(defmethod remove-back (list)                       ;;; Define a method 'remove-back' to remove a node from the back of the linked list
  (with-slots (tail) list                            ;;; Use 'with-slots' to access the instance variables of the linked list
    (when tail                                       ;;; If 'tail' is not nil, the linked list is not empty
      (let ((back tail))                             ;;; Store the current tail in 'back' variable
        (setf tail (prev tail))                      ;;; Set 'tail' to the previous node
        (when tail                                   ;;; If 'tail' is not nil, the linked list still has nodes
          (setf (next tail) nil))                    ;;; Set the new tail's 'next' pointer to nil
        (when (eq back head))                        ;;; If the node to remove is the first one in the list
          (setf head nil))                           ;;; Set 'head' to nil
        back))))                                     ;;; Return the removed node

(defmethod insert-at (list node index)               ;;; Define a method 'insert-at' to insert a node at a particular index
  (let ((curr head)                                  ;;; Store the current node in 'curr' variable
        (count 0))                                   ;;; Initialize a counter variable to keep track of the current index
    (loop while curr                                 ;;; Loop while 'curr' is not nil
      do (if (>= count index)                        ;;; If the current index is greater than or equal to the given index
             (progn                                   ;;; Execute the following code
               (setf (prev node) (prev curr))         ;;; Set the new node's 'prev' pointer to the previous node's 'prev' pointer
               (setf (next (prev curr)) node)         ;;; Set the previous node's 'next' pointer to point to the new node
               (setf (prev curr) node)                ;;; Set the current node's 'prev' pointer to point to the new node
               (setf (next node) curr)                ;;; Set the new node's 'next' pointer to point to the current node
               (unless (eq node prev curr)            ;;; Unless the previous node is the new node, set the next node's 'prev' pointer to point to the new node
                 (setf (next (prev node)) node))))
        (setf curr (next curr))                      ;;; Set 'curr' to the next node
        (incf count)))                               ;;; Increment the count variable by 1
    (cond                                            ;;; Handle edge cases
      ((< index 0) (progn                            ;;; If index is negative, add the node to the front of the linked list
                     (add-front list node)
                     t))
      ((>= index count) (progn                       ;;; If index is greater than or equal to the number of nodes in the linked list, add the node to the back of the linked list
                         (add-back list node)
                         t)))))

(defmethod delete-at (list index)                    ;;; Define a method 'delete-at' to delete a node at a particular index
  (let ((curr head)                                  ;;; Store the current node in 'curr' variable
        (count 0))                                   ;;; Initialize a counter variable to keep track of the current index
    (loop while curr                                 ;;; Loop while 'curr' is not nil
      do (if (= count index)                         ;;; If the current index is equal to the given index
             (progn                                   ;;; Execute the following code
               (let ((node (remove-front list)))      ;;; Remove the node at the front of the list and store it in 'node' variable
                 (unless (null node)                  ;;; If 'node' is not null, i.e. the list is not empty
                   (when (null (next curr))            ;;; If the current node is the last node in the list
                     (setf tail (prev curr)))         ;;; Set 'tail' to the previous node
                   (delete-next prev curr)            ;;; Delete the current node by setting the previous node's 'next' pointer to the next node
                   (delete-prev list node)            ;;; Delete the current node by setting the next node's 'prev' pointer to the previous node
                   (return-from delete-at t)))
               (incf count)))                         ;;; Increment the count variable by 1
        (setf curr (next curr))                      ;;; Set 'curr' to the next node
        (incf count)))                               ;;; Increment the count variable by 1
    nil))                                            ;;; Return nil if the given index is out of range

(defmethod delete-next (node next-node)              ;;; Define a method 'delete-next' to delete a given node's 'next' pointer
  (when (eq (next node) next-node)                   ;;; If the given node's 'next' pointer points to the next node
    (setf (next node) (next next-node))              ;;; Set the given node's 'next' pointer to point to the next node's 'next' pointer
    t))

(defmethod delete-prev (list prev-node)              ;;; Define a method 'delete-prev' to delete a given node's 'prev' pointer
  (with-slots (tail) list                            ;;; Use 'with-slots' to access the instance variables of the linked list
    (when (eq tail prev-node)                        ;;; If the given node's 'prev' pointer points to the tail
      (setf tail (prev tail))                        ;;; Set 'tail' to the previous node
      t)))                                           ;;; Return true if the given node's 'prev' pointer is successfully deleted

(defmethod print-list (list)                         ;;; Define a method 'print-list' to print the linked list
  (let ((curr head)                                  ;;; Store the current node in 'curr' variable
        (result "list: "))                          ;;; Initialize a string 'result' to hold the result
    (loop while curr                                 ;;; Loop while 'curr' is not nil
      do (progn                                      ;;; Execute the following code
        (setf result (concatenate 'string            ;;; Concatenate the given strings to the result
                        result
                        (write-to-string (value curr)) " ")))
        (setf curr (next curr)))                     ;;; Set 'curr' to the next node
    result))                                         ;;; Return the result string

(defparameter nodes (list (make-instance 'node :value 5) ;;; Create a list of 5 nodes with different integer values
                          (make-instance 'node :value 3)
                          (make-instance 'node :value 7)
                          (make-instance 'node :value 2)
                          (make-instance 'node :value 9)))

(defparameter list (make-instance 'linked-list))     ;;; Create an empty linked list instance

(map nil (lambda (node) (add-front list node)) nodes) ;;; Add the nodes to the front of the linked list

(format t "~a~%" (print-list list))                  ;;; Print the linked list

(add-back list (make-instance 'node :value 1))       ;;; Add a new node to the back of the linked list
(add-back list (make-instance 'node :value 8))

(format t "~a~%" (print-list list))                  ;;; Print the linked list

(delete-at list 3)                                   ;;; Delete the node at index 3

(format t "~a~%" (print-list list))                  ;;; Print the linked list

(insert-at list (make-instance 'node :value 4) 3)    ;;; Insert a new node with value 4 at index 3

(format t "~a~%" (print-list list))                  ;;; Print the linked list

(delete-at list 0)                                   ;;; Delete the node at index 0

(format t "~a~%" (print-list list))                  ;;; Print the linked list