(defmacro run-in-background (form &optional (milliseconds 0)) ; defining a macro named 'run-in-background' which takes two arguments, 'form' and 'milliseconds' with 'milliseconds' having a default value of 0
  (let ((func-name (make-symbol "callback"))) ; defining a variable 'func-name' and assigning it a symbol generated by the 'make-symbol' function
    `(let (*standard-output*
           (*standard-output* (make-broadcast-stream)) ; using the 'make-broadcast-stream' function to create a broadcast stream where the output is sent to multiple streams
           (*error-output* *standard-output*) ; setting the value of the '*error-output*' to equal the current '*standard-output*' stream so any errors will also be broadcasted
           (,func-name () ; using the generated symbol as a function name and defining it with an empty parameter list
             (unwind-protect ; using the 'unwind-protect' macro to ensure the code is always executed even in case of an error
                 (progn ,form ;; executing the code given as the 'form' argument
                    (fresh-line)) ; printing a new line
               (when (and (eq *standard-output* *error-output*) (streamp *standard-output*)) ; ensuring both streams are still active and checking if the current stream is the same as the error stream
                  (with-simple-restart (continue "Continue") ; using the 'with-simple-restart' macro to create a restart option called "Continue" in case of an error
                    (format *error-output* "An error occurred, do you wish to continue?")) ; printing an error message to the error stream
                  (format *error-output* "Type 'continue' to continue or 'abort' to exit: ") ; prompting the user to choose whether to continue or abort the code
                  (let ((response (read))) ; reading the user's response
                    (if (eq response 'continue) ; checking if the response is equal to 'continue'
                        (invoke-restart 'continue) ; using the 'invoke-restart' function to call the "continue" restart and continue the code
                        (error "Aborting code"))))))) ; if the response is not 'continue', an error is thrown and the code is aborted
    `(let ((process (make-process :name "background-process" ; using the 'make-process' function to create a new process with the name "background-process"
                                  :function #',func-name))) ; passing in the generated symbol as the process's function
       (when (and (integerp ,milliseconds) (plusp ,milliseconds)) ; checking if the 'milliseconds' argument is a positive integer
         (sleep ,milliseconds)) ; using the 'sleep' function to delay the execution of the process for the specified amount of time
       (setf (process-plist process) (append (process-plist process) '(process-running t))) ; using the 'setf' function to add a new key-value pair to the process's property list, indicating that the process is running
       (princ "Process started with id: " *standard-output*) ; printing a message to the standard output stream
       (princ (process-id process)) ; printing the process's id to the standard output stream
       (values)))) ; returning multiple values using the 'values' function