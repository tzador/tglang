%{
// This section is used to include header files, global variables, and any other necessary preprocessing directives or declarations.

#include <stdio.h>
#include <stdlib.h>

// Global variable declaration
int result = 0;
%}

// Tokens section, identifies the tokens to be recognized by the parser.

%token NUM
%token OP_PLUS
%token OP_MINUS
%token OP_MULT
%token OP_DIV
%token LEFT_PAREN
%token RIGHT_PAREN

// Rules section, defines the structure of the grammar and actions to be executed when a rule is matched.

%left OP_PLUS OP_MINUS
%left OP_MULT OP_DIV

%%
// Grammar rules start here

// Rule for a number
number: NUM
    { result = $1; };

// Rule for a binary expression
binary_expr: number OP_PLUS number
    { result = $1 + $3; }
    | number OP_MINUS number
    { result = $1 - $3; }
    | number OP_MULT number
    { result = $1 * $3; }
    | number OP_DIV number
    { result = $1 / $3; };

// Rule for parentheses
paren_expr: LEFT_PAREN binary_expr RIGHT_PAREN
    { result = $2; };

// Rule for an expression
expression: number
    { result = $1; }
    | binary_expr
    { result = $1; }
    | paren_expr
    { result = $1; };

// End of grammar rules

%%

// Actions section, contains the code that will be executed when a rule is matched.

// Action for handling syntax error
void eat_error()
{
    printf("Syntax error");
    exit(1);
}

// Main function, calls the parser and prints the result.
int main()
{
    // Input string to be parsed
    char input[50] = "2 + 3 * (5 - 1)";

    // Pass the input string to the parser
    yyparse(input);
    printf("Result: %d", result);

    return 0;
}

// Function automatically generated by Bison, it returns the next token.
int yylex()
{
    int val;
    scanf("%d", &val);
    return val;
}

// Function automatically generated by Bison, it handles syntax errors.
void yyerror()
{
    eat_error();
}