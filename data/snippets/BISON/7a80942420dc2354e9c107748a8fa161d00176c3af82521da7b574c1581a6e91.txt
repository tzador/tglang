%{
    # Define variables
    # This section is optional but can be useful for declaring variables and macros
    # In this case, we declare variables for the first and second non-terminals
    # and a macro for the delimiter
    int first;
    int second;
    # Macro for delimiter, can be any string
    %define DELIM '/'
%}

# Rules section
# This section defines the grammar rules for the language
# Here, we define a simple expression grammar that supports addition, subtraction, multiplication, and division
# The grammar allows for multiple expressions to be evaluated in a single line, separated by the delimiter
%%

# Define non-terminals
# In BISON, non-terminals are defined using angled brackets
# Here, we define expressions as our first non-terminal and list of expressions as our second
# We also include a rule for an empty list of expressions
expr: <expr> DELIM <expr>
    | <expr> '+' <expr>
    | <expr> '-' <expr>
    | <expr> '*' <expr>
    | <expr> '/' <expr>
    | <expr> '%' <expr>
    | <expr> '^' <expr>
    | '<' <expr> '>'
    | '-' <expr> %prec NEG
    | '(' <expr> ')'
    | '!' <expr>
    | NUMBER;

list: <list> DELIM <expr>
    | <list> DELIM
    |;

%%

# Code section
# This section contains the actual code that will be executed for each rule
# Here, we simply perform the desired operation for each expression and return the result
# We also handle any potential errors that may occur
# Note: this is just a basic implementation and does not include error handling for all cases
%%

# Code for <expr> rules
<expr>: {
    switch ($$->tag) {
        case '+':
            $$->value = ($$->children[0]->value) + ($$->children[1]->value);
            break;
        case '-':
            $$->value = ($$->children[0]->value) - ($$->children[1]->value);
            break;
        case '*':
            $$->value = ($$->children[0]->value) * ($$->children[1]->value);
            break;
        case '/':
            if ($$->children[1]->value == 0) {
                fprintf(stderr, "ERROR: Division by zero\n");
                YYABORT;
            }
            $$->value = ($$->children[0]->value) / ($$->children[1]->value);
            break;
        case '%':
            $$->value = ($$->children[0]->value) % ($$->children[1]->value);
            break;
        case '^':
            $$->value = pow($$->children[0]->value, $$->children[1]->value);
            break;
        case '>':
            if ($$->children[0]->value > $$->children[1]->value) {
                $$->value = 1;
            } else {
                $$->value = 0;
            }
            break;
        case '<':
            if ($$->children[0]->value < $$->children[1]->value) {
                $$->value = 1;
            } else {
                $$->value = 0;
            }
            break;
        case '-':
            $$->value = -($$->children[0]->value);
            break;
        case '!':
            if ($$->children[0]->value == 0) {
                $$->value = 1;
            } else {
                $$->value = 0;
            }
            break;
        case '(':
            $$->value = $$->children[0]->value;
            break;
        case NUMBER:
            $$->value = $$->children[0]->value;
            break;
    }
}

# Code for <list> rules
<list>: {
    switch ($$->tag) {
        case ',':
            if ($$->children[1] == NULL) {
                $$->value = $$->children[0]->value;
            } else {
                printf("%d\n", $$->children[0]->value);
                $$->value = $$->children[1]->value * $$->children[0]->value;
            }
            break;
        case '\n':
            if ($$->children[1] == NULL) {
                $$->value = $$->children[0]->value;
            } else {
                printf("Result: %d\n", $$->children[0]->value);
                $$->value = $$->children[1]->value * $$->children[0]->value;
            }
            break;
        case '=':
            $$->value = $$->children[0]->value;
            break;
        case NUMBER:
            $$->value = $$->children[0]->value;
            break;
        case ERROR:
            fprintf(stderr, "ERROR: Invalid syntax\n");
            YYABORT;
    }
}

%%

# Main function
# This is the entry point for the program
# Here, we initialize the scanner and parser and call yyparse() to start parsing the input
# If successful, the parser will return 0, otherwise it will return a non-zero value
int main() {
    printf("Enter expressions to evaluate separated by the delimiter [%s]\n", DELIM);
    return yyparse();
}

# Flex scanner function
# This function is generated by the flex scanner and is responsible for tokenizing the input string
%option noyywrap
%option nounput
%option noinput
%urename "yylex" "scanner"
%{
    #include "parser.h"
%}
%%

# Regular expressions for different tokens
# Here, we define the tokens for operators, parentheses, and numbers
# Note: these are just examples and can be expanded upon depending on the specific grammar
"/"             { return '/'; }
"+"             { return '+'; }
"-"             { return '-'; }
"*"             { return '*'; }
"%"             { return '%'; }
"^"             { return '^'; }
">"             { return '>'; }
"<"             { return '<'; }
"!"             { return '!'; }
"("             { return '('; }
")"             { return ')'; }
[0-9]+          { yylval.node = create_number(yytext); return NUMBER; }
[ \t]+          {}
\n              { yylval.node = create_number(yytext); return '\n'; }
.               { yylval.node = create_number(yytext); return ERROR; }