// This program generates a random maze using the Recursive Backtracker algorithm

import std.random, std.range, std.stdio;

struct Cell {
    int x;
    int y;
    bool visited = false;
    Cell[] neighbors;
}

enum Direction {
    North,
    East,
    South,
    West
}

class Maze {
    Cell[][] grid;
    int height;
    int width;

    this(int height, int width) {
        this.height = height;
        this.width = width;
        this.createGrid();
    }

    void createGrid() {
        this.grid = new Cell[][](this.height, this.width);

        /* 
        * This loop populates the grid with cells and assigns each cell's coordinates
        * Also, each cell's neighbors are set according to its position in the grid
        */
        foreach (row, r; this.grid) {
            foreach (col, c; row) {
                this.grid[r][c].x = c;
                this.grid[r][c].y = r;
                this.grid[r][c].neighbors = [
                    this.grid.get(r - 1, c),
                    this.grid.get(r, c + 1),
                    this.grid.get(r + 1, c),
                    this.grid.get(r, c - 1)
                ].filter!(c => c !is null).array;
            }
        }
    }

    Cell randomCell() {
        import std.algorithm : shuffled;

        // Returns a random cell from the grid
        Cell[] cells = this.grid.join.map!(r => r.array).array;
        return cells.shuffled.take(1)[0];
    }

    void removeWalls(Cell c1, Cell c2) {
        int x = c1.x - c2.x;
        int y = c1.y - c2.y;

        /* 
        * The walls between two adjacent cells are removed by setting the visited flag to true
        * and then connecting the cells with a "passage"
        */
        if (x == 1) {
            c1.visited = true;
            c1.neighbors[3].visited = true;
        } else if (x == -1) {
            c1.visited = true;
            c1.neighbors[1].visited = true;
        }

        if (y == 1) {
            c1.visited = true;
            c1.neighbors[0].visited = true;
        } else if (y == -1) {
            c1.visited = true;
            c1.neighbors[2].visited = true;
        }
    }

    /* 
    * This function uses a recursive backtracker algorithm to generate the maze
    * The maze is generated by starting at a random cell and carving out a path until all cells have been visited
    */
    void generate() {
        import std.container : DoublyLinkedList;
        
        // Using a doubly linked list to keep track of the visited cells
        DoublyLinkedList[Cell] visitedCells;

        Cell currentCell = this.randomCell();
        
        // The current cell is marked as visited and added to the visitedCells list
        currentCell.visited = true;
        visitedCells.addLast(currentCell);

        // While there are still unvisited cells
        while (!visitedCells.empty) {
            currentCell = visitedCells.back;
            Cell[] unvisitedNeighbors = currentCell.neighbors.filter!(n => !n.visited).array;

            // If the current cell has unvisited neighbors
            if (!unvisitedNeighbors.empty) {
                // A random unvisited neighbor is chosen and its walls are removed
                auto nextCell = unvisitedNeighbors.randomElement;
                this.removeWalls(currentCell, nextCell);

                // The nextCell is marked as visited and added to the visitedCells list
                nextCell.visited = true;
                visitedCells.addLast(nextCell);
            } else {
                // If the current cell has no unvisited neighbors, it is removed from the list
                visitedCells.popBack();
            }
        }
    }

    void printMaze() {
        // Prints the grid with walls and passages between cells
        foreach (row, r; this.grid) {
            foreach (col, c; row) {
                char[] wallRows = [
                    "+---",
                    "|   "
                ];

                char[] wallCols = ["|   "];

                // If the current cell is the first row, print the top wall
                if (r == 0) {
                    write("+---");
                }

                // Print the left wall of the current cell
                write("|");

                // If there is a passage between current cell and the next cell
                if (c + 1 in this.grid[r]) {
                    // If the current cell and the next cell have a common y-coordinate
                    if (this.grid[r][c].y == this.grid[r][c + 1].y) {
                        write("    "); 
                    } else {
                        write("   |");
                    }
                } else {
                    // If there is no passage, print a wall
                    write("   |");
                }
            }

            // Print the final wall and start a new line
            write("\n+---");

            // If the current row and the next row have a common x-coordinate
            if (r + 1 in this.grid) {
                // Print a bottom wall for each cell in the row
                writeln();
                foreach (col, c; row) {
                    writeln("|   |");
                }
            }
        }
    }
}

void main() {
    // Set the desired height and width of the maze
    int height = 10;
    int width = 10;

    // Create a new maze object
    Maze maze = new Maze(height, width);

    // Generate the maze using recursive backtracker algorithm
    maze.generate();

    // Print the generated maze
    maze.printMaze();
}