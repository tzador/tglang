{-# LANGUAGE DeriveGeneric #-}$'\n'
{-# LANGUAGE OverloadedStrings #-}$'\n'
{-# OPTIONS_GHC -Wall #-}$'\n'
import GHC.Generics$'\n'
import Data.Aeson$'\n'
import qualified Data.Text as T$'\n'
import qualified Data.Text.Encoding as TE$'\n'
import qualified Data.ByteString.Lazy as BL$'\n'$'\n'
data Person = Person { name :: T.Text, age :: Int } deriving (Show, Generic)$'\n'$'\n'
instance FromJSON Person where$'\n'
  parseJSON (Object v) = Person <$>$'\n'
                         v .: "name"$'\n'
                         <*>$'\n'
                         v .: "age"$'\n'$'\n'
instance ToJSON Person where$'\n'
  toJSON (Person name age) = object [ "name" .= name, "age" .= age ]$'\n'$'\n'
main :: IO ()$'\n'
main = do$'\n'
  let person = Person (T.pack "John") 25$'\n'
  let encoded = encode person$'\n'
  let decoded = decode encoded :: Maybe Person$'\n'
  case decoded of$'\n'
    Just p -> putStrLn $ T.unpack $ T.concat ["Name: ", name p, ", Age: ", T.pack $ show $ age p]$'\n'
    Nothing -> putStrLn "Invalid JSON"