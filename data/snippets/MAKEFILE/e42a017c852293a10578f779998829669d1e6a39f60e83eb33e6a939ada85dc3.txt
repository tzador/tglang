# This is a makefile
# It follows a specific syntax for creating rules and targets

# Variables can be defined using the syntax VARIABLE = value
# Variable names conventionally use ALL_CAPS
CC = gcc

# Targets represent the outputs that will be generated by the makefile
# Target names can be anything and are usually filenames
# To define a target, use the syntax:
# target: dependencies
target: dependency1 dependency2
	# Commands to generate the target go here
	$(CC) dependency1 dependency2 -o target

# Strictly speaking, this is not necessary in simple makefiles
# But it is good practice to include a "phony" target for cleaning up
.PHONY: clean
clean:
	rm -f target

# In addition to simple targets, makefiles can also have variables and functions
# Variables can be used to assign values to arguments passed to functions
# Functions are called using the syntax $(function arg1 arg2 ...)
# For example:
SOURCES = main.c helper.c input.c
OBJECTS = $(SOURCES:.c=.o)

# This will create a list of object files by replacing the .c extension with .o

# Conditional statements can also be used in makefiles
# They use the syntax ifeq (conditional)
ifeq ($(DEBUG), 1)
	# If DEBUG is set to 1, enable debugging symbols
	CFLAGS += -g
endif

# A makefile can also have a default target that will be executed if no target is specified
# This can be defined using the .DEFAULT_GOAL directive
.DEFAULT_GOAL := all

# Within a rule, the @ symbol can be used before a command to suppress its output
# For example:
target:
	@echo "Compiling target..."

# Comments can also be included using the # symbol at the beginning of a line
# They are ignored by the makefile

# Lastly, the makefile can also have special built-in variables that can be used
# For example, the $@ variable represents the current target being built
# And the $^ variable represents all dependencies of that target
# This can be useful for creating generic rules with multiple dependencies
# For example:
%.o: %.c
	$(CC) -c $^ -o $@