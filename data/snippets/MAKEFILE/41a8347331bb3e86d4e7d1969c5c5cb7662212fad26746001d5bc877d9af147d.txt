# This is a makefile that compiles and links multiple C++ source files
# It also uses variables and macros to make the code more robust and maintainable


# Define the compiler to be used
CC = g++

# Define any compiler flags
CCFLAGS = -Wall -g

# Define a list of source files
# Note: each filename must be separated by a space
SOURCES = main.cpp functions.cpp mathlib.cpp

# Define the name of the executable
EXECUTABLE = myprogram

# Define a phony target to specify required targets that are not actual files
# This will be useful for when we want to compile all source files and not just changed ones
.PHONY: all clean

# The all target is the default target that will be built by make if no target is specified
# It depends on the executable target, which will trigger the required compilation and linking
all: $(EXECUTABLE)

# The executable target depends on all object files to exist
# If any of them are missing or changed, make will trigger compilation and linking
$(EXECUTABLE): $(SOURCES:.cpp=.o)
	$(CC) $(CCFLAGS) -o $@ $^

# The .o files depend on their corresponding .cpp files and also on a common header file
# The rule below uses macro substitution to automatically generate the dependencies
# For example, main.cpp will generate main.d, which will contain the dependencies for main.cpp
# This will ensure that if the header file is changed, all object files will be recompiled
# The -c flag tells the compiler to only compile and not link
# The -MMD flag tells the compiler to generate a .d file with the dependencies
# The -o flag specifies the output file
%.o: %.cpp
	$(CC) $(CCFLAGS) -MMD -c -o $@ $<

# Include all the .d files that will be generated by the rule above
-include $(SOURCES:.cpp=.d)

# The clean target is used to remove all generated files
clean:
	rm -f $(EXECUTABLE)
	rm -f $(SOURCES:.cpp=.o)
	rm -f $(SOURCES:.cpp=.d)